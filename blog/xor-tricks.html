<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>关于异或运算的一些 tricks</title>
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
<link rel="stylesheet" href="/statics/style.css" type="text/css" media="all" />
<link rel="alternate" href="/rss.xml" type="application/rss+xml" title="RSS" />
<link href="https://mastodon.social/@bennyyip" rel="me">


<link rel="icon" sizes="192x192" href="/favicon.png">


<script>
(function(u, c) {
  var d = document, t = 'script', o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
  o.src = u;
  if (c) { o.addEventListener('load', function(e) { c(e); }); }
  s.parentNode.insertBefore(o, s);
})('//cdn.bootcss.com/pangu/3.3.0/pangu.min.js', function() {
  pangu.spacingPage();
});
</script>

  </head>
<body data-route=blog>
  <nav class="menu">
  <a class="menu-item " href="/about/">About</a>
  <a class="menu-item current" href="/">Blog</a>
  <a class="menu-item icon" href="http://github.com/bennyyip"><i class="fa fa-github-square"></i></a>
  <a class="menu-item icon" href="http://twitter.com/__benyip"><i class="fa fa-twitter-square"></i></a>
  <a class="menu-item icon" href="/rss.xml"><i class="fa fa-rss-square"></i></a>
  <hr>
</nav>

  <main>
    <article>
      <h1>关于异或运算的一些 tricks</h1>
      <time pubdate="pubdate">Aug 19, 2016</time>
      <h1>异或运算的一些性质</h1>
<ul>
<li>交换律：<code>a ^ b = b ^ a</code></li>
<li>结合律：<code>a ^ (b ^ c) = b ^ c</code></li>
<li>异或是异或的逆运算：<code>a ^ b = c &lt;=&gt; b ^ c = a</code></li>
</ul>
<p>推论：</p>
<ul>
<li><code>x ^ 0 = x</code></li>
<li><code>x ^ x = 0</code></li>
</ul>
<p>阅读下文之前请务必把上述几个性质搞明白。
下面介绍几个比较 tricky 的应用，越往下越复杂。</p>

<h1>简单的加密</h1>
<p>由于异或的逆运算是它本身，因此可以实现简单的加密。（其实有逆运算的运算就可以用来加密）
设明文 <code>M</code>, 密钥 <code>S</code>, 密文 <code>C</code>
加密：<code>C = M ^ S </code>
解密：<code>M = C ^ S</code></p>
<h1>交换两个数</h1>
<pre style="background-color:#ffffff;">
<code><span style="color:#323232;">a </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">^</span><span style="color:#323232;"> b;
</span><span style="color:#323232;">b </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">^</span><span style="color:#323232;"> b; </span><span style="font-style:italic;color:#969896;">// a ^ b ^ b == a
</span><span style="color:#323232;">a </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">^</span><span style="color:#323232;"> b; </span><span style="font-style:italic;color:#969896;">// a ^ b ^ a == b
</span></code></pre>
<p>这是一个广为人知却不实用的技巧，比用中间变量的方法慢且不通用。</p>
<h1>Single Number</h1>
<blockquote>
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
</blockquote>
<blockquote>
<p>Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<p>这是 leetcode 上的<a href="https://leetcode.com/problems/single-number/">一道题目</a>, 利用异或的性质可以得到一个相当简洁的解。</p>
<pre style="background-color:#ffffff;">
<code><span style="font-weight:bold;color:#a71d5d;">class </span><span style="color:#0086b3;">Solution </span><span style="color:#323232;">{
</span><span style="color:#323232;"> </span><span style="font-weight:bold;color:#a71d5d;">public</span><span style="color:#323232;">:
</span><span style="color:#323232;">  </span><span style="font-weight:bold;color:#a71d5d;">int </span><span style="font-weight:bold;color:#795da3;">singleNumber</span><span style="color:#323232;">(vector&lt;</span><span style="font-weight:bold;color:#a71d5d;">int</span><span style="color:#323232;">&gt;</span><span style="font-weight:bold;color:#a71d5d;">&amp; </span><span style="color:#323232;">nums) {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">int</span><span style="color:#323232;"> result </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span style="color:#323232;">;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">int</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">:</span><span style="color:#323232;"> nums) {
</span><span style="color:#323232;">      result</span><span style="font-weight:bold;color:#a71d5d;">^=</span><span style="color:#323232;">i;
</span><span style="color:#323232;">    }
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span style="color:#323232;"> result;
</span><span style="color:#323232;">  }
</span><span style="color:#323232;">};
</span></code></pre>
<h1>实现双向链表</h1>
<blockquote>
<p><strong>CLRS 10.2-8</strong>
Explain how to implement doubly linked lists using only one pointer value x.np per item instead of the usual two (next and prev). Assume that all pointer values can be interpreted as k-bit integers, and define x.np = x.next XOR x.prev, the k-bit &quot;exclusive-or&quot; of x.next and x.prev. (The value NIL is represented by 0). Be sure to describe what information you need to access the head of the list. Show how to implement the SEARCH, INSERT and DELETE operations on such a list. Also show how to reverse such a list in O(1) time.</p>
</blockquote>
<p>之所以写这篇 blog 其实就是因为刚刚写完这道题，觉得很新奇。这是一种特殊的双向链表，一般的双向链表的结点是有 <code>prev</code> 和 <code>next</code> 两个指针的，而它只有一个 <code>np</code> 指针，<code>np = prev ^ next</code>. 由于 <code>xor</code> 是 <code>xor</code> 的逆运算，所以 <code>np</code> <code>prev</code> <code>next</code> 三者可以知二求一，即：
<code>np = prev ^ next</code>
<code>prev = np ^ next</code>
<code>next = prev ^ np</code>
这样实现的链表空间复杂度是寻常链表的一半。而在时间复杂度方面，插入，查找，删除都是 <code>O(n)</code> 的，除了在头尾时是 <code>O(1)</code>. 但是它的 <code>reverse</code> 操作是 <code>O(1)</code> 的，只需把 <code>head</code> 和 <code>tail</code> 交换。下面它是 C++ 的实现。</p>
<pre style="background-color:#ffffff;">
<code><span style="font-weight:bold;color:#a71d5d;">#include </span><span style="color:#183691;">&lt;iostream&gt;
</span><span style="color:#323232;">
</span><span style="font-style:italic;color:#969896;">// a ^ b = c ==&gt; b ^ c = a
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">node {
</span><span style="color:#323232;">  </span><span style="font-weight:bold;color:#a71d5d;">int</span><span style="color:#323232;"> key;
</span><span style="color:#323232;">  node</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> np;  </span><span style="font-style:italic;color:#969896;">// np = prev xor next
</span><span style="color:#323232;">  </span><span style="font-weight:bold;color:#795da3;">node</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">int </span><span style="color:#323232;">val, node</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">_np </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">nullptr</span><span style="color:#323232;">) : key(val), np(_np) {}
</span><span style="color:#323232;">};
</span><span style="color:#323232;">
</span><span style="font-weight:bold;color:#a71d5d;">class </span><span style="color:#0086b3;">xor_list </span><span style="color:#323232;">{
</span><span style="color:#323232;"> </span><span style="font-weight:bold;color:#a71d5d;">public</span><span style="color:#323232;">:
</span><span style="color:#323232;">  </span><span style="font-weight:bold;color:#795da3;">xor_list</span><span style="color:#323232;">() : head(</span><span style="color:#0086b3;">nullptr</span><span style="color:#323232;">), tail(</span><span style="color:#0086b3;">nullptr</span><span style="color:#323232;">) {}
</span><span style="color:#323232;">
</span><span style="color:#323232;">  </span><span style="font-weight:bold;color:#a71d5d;">void </span><span style="font-weight:bold;color:#795da3;">insert</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">int </span><span style="color:#323232;">val) {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">!</span><span style="color:#323232;">head) {
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">auto</span><span style="color:#323232;"> to_insert </span><span style="font-weight:bold;color:#a71d5d;">= new </span><span style="color:#323232;">node(val);
</span><span style="color:#323232;">      head </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> to_insert;
</span><span style="color:#323232;">      tail </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> to_insert;
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">return</span><span style="color:#323232;">;
</span><span style="color:#323232;">    }
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#323232;">(tail) {
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">auto</span><span style="color:#323232;"> to_insert </span><span style="font-weight:bold;color:#a71d5d;">= new </span><span style="color:#323232;">node(val, ptr_xor(tail, </span><span style="color:#0086b3;">nullptr</span><span style="color:#323232;">));
</span><span style="color:#323232;">      tail-&gt;np </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">ptr_xor(prev_ptr(tail, </span><span style="color:#0086b3;">nullptr</span><span style="color:#323232;">), to_insert);
</span><span style="color:#323232;">      tail </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> to_insert;
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">return</span><span style="color:#323232;">;
</span><span style="color:#323232;">    }
</span><span style="color:#323232;">  }
</span><span style="color:#323232;">
</span><span style="color:#323232;">  node</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="font-weight:bold;color:#795da3;">search</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">int </span><span style="color:#323232;">val) {
</span><span style="color:#323232;">    node</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> prev </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">nullptr</span><span style="color:#323232;">;
</span><span style="color:#323232;">    node</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> next;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">auto</span><span style="color:#323232;"> ptr </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> head;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">while </span><span style="color:#323232;">(ptr) {
</span><span style="color:#323232;">      next </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">next_ptr(prev, ptr);
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#323232;">(ptr-&gt;key </span><span style="font-weight:bold;color:#a71d5d;">==</span><span style="color:#323232;"> val) </span><span style="font-weight:bold;color:#a71d5d;">return</span><span style="color:#323232;"> ptr;
</span><span style="color:#323232;">      prev </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> ptr;
</span><span style="color:#323232;">      ptr </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> next;
</span><span style="color:#323232;">    }
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">nullptr</span><span style="color:#323232;">;
</span><span style="color:#323232;">  }
</span><span style="color:#323232;">
</span><span style="color:#323232;">  node</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="font-weight:bold;color:#795da3;">remove</span><span style="color:#323232;">(node</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">to_remove) {
</span><span style="color:#323232;">    node</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> prev </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">nullptr</span><span style="color:#323232;">;
</span><span style="color:#323232;">    node</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> next;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">auto</span><span style="color:#323232;"> ptr </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> head;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">while </span><span style="color:#323232;">(ptr) {
</span><span style="color:#323232;">      next </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">next_ptr(prev, ptr);
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#323232;">(ptr </span><span style="font-weight:bold;color:#a71d5d;">==</span><span style="color:#323232;"> to_remove) </span><span style="font-weight:bold;color:#a71d5d;">break</span><span style="color:#323232;">;
</span><span style="color:#323232;">      prev </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> ptr;
</span><span style="color:#323232;">      ptr </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> next;
</span><span style="color:#323232;">    }
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#323232;">(ptr </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">nullptr</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">nullptr</span><span style="color:#323232;">;
</span><span style="color:#323232;">    prev-&gt;np </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">ptr_xor(prev_ptr(prev, ptr), next);
</span><span style="color:#323232;">    next-&gt;np </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">ptr_xor(prev, next_ptr(ptr, next));
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">delete</span><span style="color:#323232;"> ptr;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span style="color:#323232;"> next;
</span><span style="color:#323232;">  }
</span><span style="color:#323232;">
</span><span style="color:#323232;">  </span><span style="font-weight:bold;color:#a71d5d;">void </span><span style="font-weight:bold;color:#795da3;">reverse</span><span style="color:#323232;">() {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">auto</span><span style="color:#323232;"> tmp </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> head;
</span><span style="color:#323232;">    head </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> tail;
</span><span style="color:#323232;">    tail </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> tmp;
</span><span style="color:#323232;">  }
</span><span style="color:#323232;">
</span><span style="color:#323232;">  </span><span style="font-weight:bold;color:#a71d5d;">void </span><span style="font-weight:bold;color:#795da3;">show</span><span style="color:#323232;">() {
</span><span style="color:#323232;">    node</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> prev </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">nullptr</span><span style="color:#323232;">;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">auto</span><span style="color:#323232;"> ptr </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> head;
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">while </span><span style="color:#323232;">(ptr) {
</span><span style="color:#323232;">      std::cout </span><span style="font-weight:bold;color:#a71d5d;">&lt;&lt;</span><span style="color:#323232;"> ptr-&gt;key </span><span style="font-weight:bold;color:#a71d5d;">&lt;&lt; </span><span style="color:#183691;">&quot;, &quot;</span><span style="color:#323232;">;
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">auto</span><span style="color:#323232;"> next </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">ptr_xor(prev, ptr-&gt;np);
</span><span style="color:#323232;">      prev </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> ptr;
</span><span style="color:#323232;">      ptr </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> next;
</span><span style="color:#323232;">    }
</span><span style="color:#323232;">    std::cout </span><span style="font-weight:bold;color:#a71d5d;">&lt;&lt;</span><span style="color:#323232;"> std::endl;
</span><span style="color:#323232;">  }
</span><span style="color:#323232;">
</span><span style="color:#323232;"> </span><span style="font-weight:bold;color:#a71d5d;">private</span><span style="color:#323232;">:
</span><span style="color:#323232;">  node</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="font-weight:bold;color:#795da3;">ptr_xor</span><span style="color:#323232;">(node</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">lhs, node</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">rhs) {
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#323232;">(node</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">)((</span><span style="font-weight:bold;color:#a71d5d;">unsigned long</span><span style="color:#323232;">)lhs </span><span style="font-weight:bold;color:#a71d5d;">^ </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">unsigned long</span><span style="color:#323232;">)rhs);
</span><span style="color:#323232;">  }
</span><span style="color:#323232;">
</span><span style="color:#323232;">  node</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="font-weight:bold;color:#795da3;">prev_ptr</span><span style="color:#323232;">(node</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">curr, node</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">next) { </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#323232;">ptr_xor(curr-&gt;np, next); }
</span><span style="color:#323232;">  node</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="font-weight:bold;color:#795da3;">next_ptr</span><span style="color:#323232;">(node</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">prev, node</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">curr) { </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#323232;">ptr_xor(prev, curr-&gt;np); }
</span><span style="color:#323232;">
</span><span style="color:#323232;"> </span><span style="font-weight:bold;color:#a71d5d;">private</span><span style="color:#323232;">:
</span><span style="color:#323232;">  node</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> head;
</span><span style="color:#323232;">  node</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> tail;
</span><span style="color:#323232;">};
</span><span style="color:#323232;">
</span><span style="font-style:italic;color:#969896;">// test
</span><span style="font-weight:bold;color:#a71d5d;">int </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
</span><span style="color:#323232;">  xor_list xl;
</span><span style="color:#323232;">  </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">int</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span style="color:#323232;">; i </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">10</span><span style="color:#323232;">; </span><span style="font-weight:bold;color:#a71d5d;">++</span><span style="color:#323232;">i) {
</span><span style="color:#323232;">    xl.insert(i);
</span><span style="color:#323232;">  }
</span><span style="color:#323232;">  xl.show();
</span><span style="color:#323232;">  xl.remove(xl.search(</span><span style="color:#0086b3;">4</span><span style="color:#323232;">));
</span><span style="color:#323232;">  xl.show();
</span><span style="color:#323232;">  xl.reverse();
</span><span style="color:#323232;">  xl.show();
</span><span style="color:#323232;">}
</span></code></pre>

    </article>
  </main>
  <footer>
  <hr>
  <p>
    <a href="/license/">CC BY-SA 4.0 / MIT</a>
    -
    <a href="https://github.com/cobalt-org/cobalt.rs">Built with Cobalt</a>
  </p>
  <br>
</footer>

</body>
</html>
