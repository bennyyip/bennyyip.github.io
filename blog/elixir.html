<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>试水 Elixir</title>
<link href=" https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css " rel="stylesheet">
<link
  rel="stylesheet"
  href="/statics/style.css"
  type="text/css"
  media="all" />
<link
  rel="alternate"
  href="/rss.xml"
  type="application/rss+xml"
  title="RSS" />
<link href="https://mastodon.social/@bennyyip" rel="me">
<script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>

<link
rel="shortcut icon"
  sizes="32x32"
  href="favicon.ico">


<script>
  document.addEventListener('DOMContentLoaded', () => {

// listen to any DOM change and automatically perform spacing via MutationObserver()
    pangu.autoSpacingPage();
  });
</script>

  </head>
<body data-route=blog>
  <nav class="menu">
  <a class="menu-item " href="/about/">About</a>
  <a class="menu-item current" href="/">Blog</a>
  <a class="menu-item icon" href="http://github.com/bennyyip"><i class="fa fa-github-square"></i></a>
  <a class="menu-item icon" href="http://twitter.com/__benyip"><i class="fa fa-twitter-square"></i></a>
  <a class="menu-item icon" href="/rss.xml"><i class="fa fa-rss-square"></i></a>
  <hr>
</nav>

  <main>
    <article>
      <h1>试水 Elixir</h1>
      <time pubdate="pubdate">Jan 22, 2018</time>
      <p>我这个星期接触了 Elixir，遇到蛮多有趣的东西，于是写 blog 分享下。官方的介绍如下：</p>
<blockquote>
<p>Elixir is a dynamic, functional language designed for building scalable and maintainable applications.</p>
</blockquote>
<p>要用一句话概括这语言给我的感觉就是：「皮是 Ruby, 肉是 Erlang, 骨是 Lisp」。</p>

<h1>Why Elixir Rocks</h1>
<h3>Macro x Metaprogramming x DSL</h3>
<p>讲 macro 之前先讲讲 AST。Elixir 的 AST 非常简单，要么是 literals（Atom, String, List, Number, Tuple with 2 element），要么是这样的 <code>tuple</code>：</p>
<pre style="background-color:#ffffff;">
<code><span style="color:#323232;">{atom </span><span style="font-weight:bold;color:#a71d5d;">| </span><span style="color:#323232;">tuple, list, list </span><span style="font-weight:bold;color:#a71d5d;">| </span><span style="color:#323232;">atom}
</span></code></pre>
<ul>
<li>第一部分是 <code>atom</code> 或者另外一个这样的 <code>tuple</code></li>
<li>第二部分是 metadata，一个 keyword list</li>
<li>第三部分要么是函数的参数列表，要么是一个 <code>atom</code>。如果是 <code>atom</code> 表明这个 tuple 是个变量。</li>
</ul>
<p>Elixir 提供了 <code>quote/unquote</code>（类似 lisp 里的 <code>quasiquote / unquote</code> )，quote 一个表达式即可得到它的 AST(Abstract Syntax Tree)。
所谓 macro 就是接受 AST 返回 AST 的函数，这样形式简单的 AST 给 macro 的编写带来了方便。
Elixir 只有少数几个 <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html">Sepcial Forms</a>, 表面那些像 Ruby 的语法基本上都是用 macro 造出来的，这一点很像 Lisp。
<code>if/else</code> 是宏，<code>defstruct</code> 是宏，<code>|&gt;</code> 管道运算符也是一个宏，它用起来是这样的：</p>
<pre style="background-color:#ffffff;">
<code><span style="font-style:italic;color:#969896;"># without |&gt;
</span><span style="color:#323232;">foo(bar(baz, meow))
</span><span style="font-style:italic;color:#969896;"># with |&gt;
</span><span style="color:#323232;">baz </span><span style="font-weight:bold;color:#a71d5d;">|&gt; </span><span style="color:#323232;">bar(meow) </span><span style="font-weight:bold;color:#a71d5d;">|&gt; </span><span style="color:#323232;">foo
</span></code></pre>
<p>而所谓 metaprogramming 就是写生成代码的代码。macro 提供了把代码当数据处理的能力，于是乎可以用来做元编程。</p>
<p>元编程可以用来在语言里造 <a href="https://en.wikipedia.org/wiki/Domain-specific_language">Domain-specific languages (DSL)</a> 来生成 boilerplate 代码，于是就可以写出这样的代码：</p>
<pre style="background-color:#ffffff;">
<code><span style="font-style:italic;color:#969896;"># Imports only from/2 of Ecto.Query
</span><span style="font-weight:bold;color:#a71d5d;">import </span><span style="color:#0086b3;">Ecto</span><span style="color:#323232;">.</span><span style="color:#0086b3;">Query</span><span style="color:#323232;">, </span><span style="color:#0086b3;">only: </span><span style="color:#323232;">[</span><span style="color:#0086b3;">from: 2</span><span style="color:#323232;">]
</span><span style="color:#323232;">
</span><span style="font-style:italic;color:#969896;"># Create a query
</span><span style="color:#323232;">query </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">from u </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#183691;">&quot;users&quot;</span><span style="color:#323232;">,
</span><span style="color:#323232;">          </span><span style="color:#0086b3;">where: </span><span style="color:#323232;">u.age </span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#0086b3;">18</span><span style="color:#323232;">,
</span><span style="color:#323232;">          </span><span style="color:#0086b3;">select: </span><span style="color:#323232;">u.name
</span><span style="color:#323232;">
</span><span style="font-style:italic;color:#969896;"># Send the query to the repository
</span><span style="color:#0086b3;">Repo</span><span style="color:#323232;">.all(query)
</span></code></pre>
<p>ecto 是用来操作数据库的库，它提供了类似 SQL 的 DSL。<code>query</code> 通过宏展开最后变成了一个 Elixir 的函数。</p>
<p>另外 Elixir 的 macro 是 hygienic 的，不像 C 的基于字符替换的宏，会污染调用方的 namespace。但是它也提供了 var! 来打破这个 hygiene，从而往调用方的塞变量。</p>
<h3>Pattern Matching</h3>
<p>Elixir 到处都是 pattern matching，实际上 <code>=</code> 是 match 操作符。Rust 里面同样有 pattern matching，但是功能不如 Elixir 的强大。 在 Rust 里我们通常用它来 match enum(tagged union)，<code>std::Result</code>就是一个好例子。</p>
<p>Elixr 这边还能 match 很多 Rust 不能 match 的类型，比如 list（Rust 的 slice pattern 还是 experimental)：</p>
<pre style="background-color:#ffffff;">
<code><span style="color:#323232;">iex</span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#323232;">[head </span><span style="font-weight:bold;color:#a71d5d;">| </span><span style="color:#323232;">tail] </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">[</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">]
</span><span style="color:#323232;">[</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">]
</span><span style="color:#323232;">iex</span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#323232;">head
</span><span style="color:#0086b3;">1
</span><span style="color:#323232;">iex</span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#323232;">tail
</span><span style="color:#323232;">[</span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">]
</span></code></pre>
<p>比如字符串：</p>
<pre style="background-color:#ffffff;">
<code><span style="color:#323232;">iex</span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#183691;">&quot;he&quot; </span><span style="font-weight:bold;color:#a71d5d;">&lt;&gt; </span><span style="color:#323232;">rest </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;hello&quot;
</span><span style="color:#183691;">&quot;hello&quot;
</span><span style="color:#323232;">iex</span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#323232;">rest
</span><span style="color:#183691;">&quot;llo&quot;
</span></code></pre>
<p>这个其实有局限性，只有最后一部分可以是变量。
比如 map:</p>
<pre style="background-color:#ffffff;">
<code><span style="color:#323232;">iex</span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#323232;">%{} </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">%{</span><span style="color:#0086b3;">:a </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">:b</span><span style="color:#323232;">}
</span><span style="color:#323232;">%{</span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">:b</span><span style="color:#323232;">, </span><span style="color:#0086b3;">:a </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">1</span><span style="color:#323232;">}
</span><span style="color:#323232;">iex</span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#323232;">%{</span><span style="color:#0086b3;">:a </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">a} </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">%{</span><span style="color:#0086b3;">:a </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">:b</span><span style="color:#323232;">}
</span><span style="color:#323232;">%{</span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">:b</span><span style="color:#323232;">, </span><span style="color:#0086b3;">:a </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">1</span><span style="color:#323232;">}
</span><span style="color:#323232;">iex</span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#323232;">a
</span><span style="color:#0086b3;">1
</span><span style="color:#323232;">iex</span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#323232;">%{</span><span style="color:#0086b3;">:c </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">c} </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">%{</span><span style="color:#0086b3;">:a </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">:b</span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">** </span><span style="color:#323232;">(</span><span style="color:#0086b3;">MatchError</span><span style="color:#323232;">) no match of right hand side </span><span style="color:#0086b3;">value: </span><span style="color:#323232;">%{</span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">:b</span><span style="color:#323232;">, </span><span style="color:#0086b3;">:a </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">1</span><span style="color:#323232;">}
</span></code></pre>
<p>我学 Elixir 的时候用它做了个 telegram bot。用户发来的消息是这样格式的：</p>
<pre style="background-color:#ffffff;">
<code><span style="color:#323232;">/command [optional data]
</span><span style="color:#323232;">or
</span><span style="color:#323232;">/command@bot_name [optional data]
</span></code></pre>
<p>这里就需要把不同的消息 route 到不同的 handler。在别的语言大概是需要维护一个 hash table，把 pattern 和 handler 注册进去，收到消息就对着 hash table 一项一项地 match。而我用的库很巧妙地利用 pattern matching 解决了这个问题：</p>
<pre style="background-color:#ffffff;">
<code><span style="color:#323232;">  </span><span style="font-weight:bold;color:#a71d5d;">defp </span><span style="font-weight:bold;color:#795da3;">generate_command</span><span style="color:#323232;">(command, handler) </span><span style="font-weight:bold;color:#a71d5d;">do
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">quote do
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">def </span><span style="font-weight:bold;color:#795da3;">do_match_message</span><span style="color:#323232;">(
</span><span style="color:#323232;">            %{
</span><span style="color:#323232;">              </span><span style="color:#0086b3;">message: </span><span style="color:#323232;">%{
</span><span style="color:#323232;">                </span><span style="color:#0086b3;">text: </span><span style="color:#183691;">&quot;/&quot; </span><span style="font-weight:bold;color:#a71d5d;">&lt;&gt; unquote</span><span style="color:#323232;">(command)
</span><span style="color:#323232;">              }
</span><span style="color:#323232;">            } </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">var!(update)
</span><span style="color:#323232;">          ) </span><span style="font-weight:bold;color:#a71d5d;">do
</span><span style="color:#323232;">        handle_message(</span><span style="font-weight:bold;color:#a71d5d;">unquote</span><span style="color:#323232;">(handler), [var!(update)])
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">end
</span><span style="color:#323232;">
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">def </span><span style="font-weight:bold;color:#795da3;">do_match_message</span><span style="color:#323232;">(
</span><span style="color:#323232;">            %{
</span><span style="color:#323232;">              </span><span style="color:#0086b3;">message: </span><span style="color:#323232;">%{
</span><span style="color:#323232;">                </span><span style="color:#0086b3;">text: </span><span style="color:#183691;">&quot;/&quot; </span><span style="font-weight:bold;color:#a71d5d;">&lt;&gt; unquote</span><span style="color:#323232;">(command) </span><span style="font-weight:bold;color:#a71d5d;">&lt;&gt; </span><span style="color:#183691;">&quot; &quot; </span><span style="font-weight:bold;color:#a71d5d;">&lt;&gt; </span><span style="color:#323232;">_
</span><span style="color:#323232;">              }
</span><span style="color:#323232;">            } </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">var!(update)
</span><span style="color:#323232;">          ) </span><span style="font-weight:bold;color:#a71d5d;">do
</span><span style="color:#323232;">        handle_message(</span><span style="font-weight:bold;color:#a71d5d;">unquote</span><span style="color:#323232;">(handler), [var!(update)])
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">end
</span><span style="color:#323232;">
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">def </span><span style="font-weight:bold;color:#795da3;">do_match_message</span><span style="color:#323232;">(
</span><span style="color:#323232;">            %{
</span><span style="color:#323232;">              </span><span style="color:#0086b3;">message: </span><span style="color:#323232;">%{
</span><span style="color:#323232;">                </span><span style="color:#0086b3;">text: </span><span style="color:#183691;">&quot;/&quot; </span><span style="font-weight:bold;color:#a71d5d;">&lt;&gt; unquote</span><span style="color:#323232;">(command) </span><span style="font-weight:bold;color:#a71d5d;">&lt;&gt; </span><span style="color:#183691;">&quot;@&quot; </span><span style="font-weight:bold;color:#a71d5d;">&lt;&gt; unquote</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">@</span><span style="color:#0086b3;">bot_name</span><span style="color:#323232;">)
</span><span style="color:#323232;">              }
</span><span style="color:#323232;">            } </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">var!(update)
</span><span style="color:#323232;">          ) </span><span style="font-weight:bold;color:#a71d5d;">do
</span><span style="color:#323232;">        handle_message(</span><span style="font-weight:bold;color:#a71d5d;">unquote</span><span style="color:#323232;">(handler), [var!(update)])
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">end
</span><span style="color:#323232;">
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">def </span><span style="font-weight:bold;color:#795da3;">do_match_message</span><span style="color:#323232;">(
</span><span style="color:#323232;">            %{
</span><span style="color:#323232;">              </span><span style="color:#0086b3;">message: </span><span style="color:#323232;">%{
</span><span style="color:#323232;">                </span><span style="color:#0086b3;">text: </span><span style="color:#183691;">&quot;/&quot; </span><span style="font-weight:bold;color:#a71d5d;">&lt;&gt; unquote</span><span style="color:#323232;">(command) </span><span style="font-weight:bold;color:#a71d5d;">&lt;&gt; </span><span style="color:#183691;">&quot;@&quot; </span><span style="font-weight:bold;color:#a71d5d;">&lt;&gt; unquote</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">@</span><span style="color:#0086b3;">bot_name</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">&lt;&gt; </span><span style="color:#183691;">&quot; &quot; </span><span style="font-weight:bold;color:#a71d5d;">&lt;&gt; </span><span style="color:#323232;">_
</span><span style="color:#323232;">              }
</span><span style="color:#323232;">            } </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">var!(update)
</span><span style="color:#323232;">          ) </span><span style="font-weight:bold;color:#a71d5d;">do
</span><span style="color:#323232;">        handle_message(</span><span style="font-weight:bold;color:#a71d5d;">unquote</span><span style="color:#323232;">(handler), [var!(update)])
</span><span style="color:#323232;">      </span><span style="font-weight:bold;color:#a71d5d;">end
</span><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">end
</span><span style="color:#323232;">  </span><span style="font-weight:bold;color:#a71d5d;">end
</span></code></pre>
<p>上面是 <code>Router</code> 核心的代码，<code>Poller</code> 收到消息就调用 <code>do_match_message</code> 对其进行处理。
这个库把用户提供的 <code>command</code> 和 <code>bot_name</code> 来重载 <code>do_match_message</code> 函数，对 <code>update</code> 做 pattern matching，从而把消息 route 到相应的 handler。
用 macro 包装一下，用户需要写的代码就成了这样，减少了大量 boilerplate ：</p>
<pre style="background-color:#ffffff;">
<code><span style="color:#323232;">  command [</span><span style="color:#183691;">&quot;hello&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;hi&quot;</span><span style="color:#323232;">] </span><span style="font-weight:bold;color:#a71d5d;">do
</span><span style="color:#323232;">    </span><span style="color:#0086b3;">Logger</span><span style="color:#323232;">.log </span><span style="color:#0086b3;">:info</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;Command /hello or /hi&quot;
</span><span style="color:#323232;">
</span><span style="color:#323232;">    send_message </span><span style="color:#183691;">&quot;Hello World!&quot;
</span><span style="font-weight:bold;color:#a71d5d;">end
</span></code></pre>
<h3>Erlang/OTP</h3>
<p>Elixir 是 Erlang VM 上的语言，自然是要跟 OTP 打交道的。但是 OTP 是什么？</p>
<blockquote>
<p>OTP (Open Telecom Platform) is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications.</p>
</blockquote>
<p>事实上很大程度上我用 Elixir 就是因为 Erlang/OTP，否则语言设计得再妙，没了 Erlang VM 的支撑我大概也不会去尝试。Erlang 提供了有如操作系统一般的 VM，对于分布式 / 并发的问题有非常独到的解决方法。而 Erlang 略显鬼畜的语法是我迟迟没有去接触它的原因，Elixir 让我有机会这一窥究竟。</p>
<p>这一部分我理解还是比较浅薄，而且 Erlang/OTP 确实比较复杂，推荐读陈天写的<a href="https://zhuanlan.zhihu.com/p/26341437">介绍文章</a>。</p>
<h3>Mix</h3>
<p>8102 年了，各种语言基本都把好用的构建工具和编译器一起 ship。mix 提供了<strong>创建项目，包管理，编译，测试，文档，格式化代码</strong>一条龙服务。</p>
<p>而且它是 extensible，用户可以自定义 task。下面提到的 linter 就是自定义的 task。</p>
<p>P.S. 我蛮喜欢 mix 这个名字，因为 Elixir 是炼金术术语，意思是万能药。这个语境下，mix 像是混合试剂的意思。</p>
<h1>开发环境配置</h1>
<h3>安装编译器以及文档：</h3>
<pre style="background-color:#ffffff;">
<code><span style="color:#323232;">pacman -S elixir elixir-docs
</span></code></pre>
<p><code>elixir</code> 主要包含了编译器 ( <code>elixirc</code> ), REPL( <code>iex</code> ) 以及构建工具 ( <code>mix</code> ).
<code>elixir-docs</code> 在<code>archlinuxcn</code>源里（我打的包），包含了 Elixir 自带的库以及工具链的文档。
第三方库可以到 <a href="https://hexdocs.pm">hexdocs</a> 查，或者用</p>
<pre style="background-color:#ffffff;">
<code><span style="color:#323232;">mix hex.doc open PACKAGE </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">VERSION</span><span style="font-weight:bold;color:#a71d5d;">]
</span></code></pre>
<h3>装 Vim 插件：</h3>
<pre style="background-color:#ffffff;">
<code><span style="color:#323232;">Plug </span><span style="color:#183691;">&#39;elixir-editors/vim-elixir&#39;                    </span><span style="font-style:italic;color:#969896;">&quot;语法高亮，缩进规则
</span><span style="color:#323232;">Plug </span><span style="color:#183691;">&#39;mhinz/vim-mix-format&#39;</span><span style="color:#323232;">, { </span><span style="color:#183691;">&#39;for&#39;</span><span style="color:#323232;">: </span><span style="color:#183691;">&#39;elixir&#39;</span><span style="color:#323232;"> }    </span><span style="font-style:italic;color:#969896;">&quot;格式化代码，需要 elixir1.6
</span><span style="color:#323232;">Plug </span><span style="color:#183691;">&#39;slashmili/alchemist.vim&#39;</span><span style="color:#323232;">, { </span><span style="color:#183691;">&#39;for&#39;</span><span style="color:#323232;">: </span><span style="color:#183691;">&#39;elixir&#39;</span><span style="color:#323232;"> } </span><span style="font-style:italic;color:#969896;">&quot;补全及跳转
</span></code></pre>
<p>BTW, Elixir 也有 LSP 实现（https://github.com/JakeBecker/elixir-ls）。Vim 对 LSP 的支持还不够好，用 VS Code 的话可以试试。</p>
<h3>Linter</h3>
<p>Elixir 可以用 <a href="https://github.com/rrrene/credo">credo</a> 做静态分析，在 mix.exs 的 deps 里加一行即可：</p>
<pre style="background-color:#ffffff;">
<code><span style="font-weight:bold;color:#a71d5d;">defp </span><span style="font-weight:bold;color:#795da3;">deps </span><span style="font-weight:bold;color:#a71d5d;">do
</span><span style="color:#323232;">  [
</span><span style="color:#323232;">      {</span><span style="color:#0086b3;">:credo</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;~&gt; 0.9.0-rc1&quot;</span><span style="color:#323232;">, </span><span style="color:#0086b3;">only: </span><span style="color:#323232;">[</span><span style="color:#0086b3;">:dev</span><span style="color:#323232;">, </span><span style="color:#0086b3;">:test</span><span style="color:#323232;">], </span><span style="color:#0086b3;">runtime: false</span><span style="color:#323232;">}
</span><span style="color:#323232;">  ]
</span><span style="font-weight:bold;color:#a71d5d;">end
</span></code></pre>
<h3>其它</h3>
<p>Elixir 的包托管在 <a href="https://hex.pm">hex</a>，由于众所周知的问题，在中国大陆访问速度很慢。请心里默念「FUCK GFW」并在 <code>~/.hex/hex.config</code> 加一行代理：</p>
<pre style="background-color:#ffffff;">
<code><span style="color:#323232;">{http_proxy,«</span><span style="color:#183691;">&quot;http://127.0.0.1:1081&quot;</span><span style="color:#323232;">»}.
</span></code></pre>
<h1>总结</h1>
<p>Elixir 背靠 Erlang/OTP，同时语言设计精良，工具链完善，适合写健壮的，scalable 的应用，值得一试。</p>

    </article>
  </main>
  <footer>
  <hr>
  <p>
    <a href="/license/">CC BY-SA 4.0 / MIT</a>
    -
    <a href="https://github.com/cobalt-org/cobalt.rs">Built with Cobalt</a>
  </p>
  <br>
</footer>

</body>
</html>
